package sensor

import (
	"os/exec"
	"strconv"
	"fmt"
)


type CommandBackedSensor struct {
	id      string 
	command string 
	args 	[]string
}


func FromCommand(id, command string, args ...string) Sensor {
	_, err := exec.LookPath(command)
	if err != nil {
		panic("Executable not in path: "+command)
	}
	return &CommandBackedSensor{id, command, args}
}


func (S *CommandBackedSensor) Id() string {
	return S.id
}


func (S *CommandBackedSensor) Sample() float32 {

	cmd := exec.Command(S.command, S.args...)
	out, err := cmd.CombinedOutput()
	if err != nil {
		panic("Execution failed: "+S.command)
	}
	if out[len(out)-1] == '\n' {
		// command output usually has a trailing \n
		out = out [0:len(out)-1]
	}

	res, err := strconv.ParseFloat(string(out), 32)
	if err != nil {
		fmt.Println(err)
		panic("Can't convert: "+string(out))
	}

	return float32(res)
}