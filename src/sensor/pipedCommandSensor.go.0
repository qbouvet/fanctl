package sensor


import (
	"os/exec"
	"strconv"
	"io"
	"bytes"
)


type PipedCommandSensor struct {
	id 	  string
	cmd1  string
	args1 []string
	cmd2  string
	args2 []string
}


func FromPipedCommand (id string) Sensor {
	return &PipedCommandSensor{id, "s-tui", []string{"-t"}, "sed", []string{"s|.*Util: Avg: \\([0-9.]*\\).*|\\1|"}}
}


func (S *PipedCommandSensor) Id() string {
	return S.id
}


func (S *PipedCommandSensor) Sample() float32 {
	cmd1 := exec.Command(S.cmd1, S.args1...)
	cmd2 := exec.Command(S.cmd2, S.args2...)
	rd,wr := io.Pipe()
	var bout bytes.Buffer

	cmd1.Stdout = wr
	cmd2.Stdin  = rd
	cmd2.Stdout = &bout

	cmd1.Start()
	cmd2.Start()
	cmd1.Wait()
	wr.Close()
	cmd2.Wait()
	rd.Close()
	
	out := (&bout).String()
	if out[len(out)-1] == '\n' {
		// command output usually has a trailing \n
		out = out [0:len(out)-1]
	}

	res, err := strconv.ParseFloat(string(out), 32)
	if err != nil {
		panic("Can't convert: "+string(out))
	}

	return float32(res)
}
